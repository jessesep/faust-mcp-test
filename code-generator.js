#!/usr/bin/env node

/**
 * Faust Code Generator
 *
 * Generates production-ready Faust DSP code from templates.
 * Supports oscillators, filters, effects, envelopes, and custom patterns.
 */

const fs = require('fs');
const path = require('path');

/**
 * CodeTemplate: Base class for all code templates
 */
class CodeTemplate {
  constructor(name, description, category) {
    this.name = name;
    this.description = description;
    this.category = category;
  }

  /**
   * Generate code from template
   * @param {object} params - Template parameters
   * @returns {string} Generated Faust code
   */
  generate(params) {
    throw new Error('Subclasses must implement generate()');
  }

  /**
   * Validate parameters
   * @param {object} params - Parameters to validate
   * @returns {object} Validation result
   */
  validateParams(params) {
    return { valid: true, errors: [] };
  }
}

/**
 * OscillatorTemplate: Generate oscillator code
 */
class OscillatorTemplate extends CodeTemplate {
  constructor() {
    super('oscillator', 'Generate oscillator (sine, saw, square, triangle)', 'synthesis');
    this.waveforms = ['sine', 'sawtooth', 'square', 'triangle', 'pulse'];
  }

  validateParams(params) {
    const errors = [];
    if (!params.waveform || !this.waveforms.includes(params.waveform)) {
      errors.push(`Invalid waveform. Must be one of: ${this.waveforms.join(', ')}`);
    }
    if (params.freqMin && params.freqMax && params.freqMin >= params.freqMax) {
      errors.push('freqMin must be less than freqMax');
    }
    return { valid: errors.length === 0, errors };
  }

  generate(params) {
    const {
      waveform = 'sine',
      freqDefault = 440,
      freqMin = 20,
      freqMax = 20000,
      gainDefault = 0.5,
      name = waveform + '_osc'
    } = params;

    const oscFunction = this.getOscFunction(waveform);
    const description = this.getDescription(waveform);

    return `// ═══════════════════════════════════════════════════════════════════════════
// ${waveform.toUpperCase()} OSCILLATOR
// ═══════════════════════════════════════════════════════════════════════════
//
// ${description}
//
// Generated by Faust Code Generator
// Timestamp: ${new Date().toISOString()}
//
// ═══════════════════════════════════════════════════════════════════════════

import("stdfaust.lib");

// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

freq = hslider("[0]Frequency (Hz)", ${freqDefault}, ${freqMin}, ${freqMax}, 0.1);
gain = hslider("[1]Amplitude", ${gainDefault}, 0, 1, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name} = ${oscFunction}(freq) * gain;

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};

// ═══════════════════════════════════════════════════════════════════════════
`;
  }

  getOscFunction(waveform) {
    const functions = {
      'sine': 'os.osc',
      'sawtooth': 'os.sawtooth',
      'square': 'os.square',
      'triangle': 'os.triangle',
      'pulse': 'os.pulsetrain'
    };
    return functions[waveform] || 'os.osc';
  }

  getDescription(waveform) {
    const descriptions = {
      'sine': 'Pure sine wave - fundamental waveform for synthesis',
      'sawtooth': 'Sawtooth wave - rich harmonic content for subtractive synthesis',
      'square': 'Square wave - odd harmonics for hollow, reed-like tones',
      'triangle': 'Triangle wave - softer than square, fewer harmonics',
      'pulse': 'Pulse wave - variable duty cycle for timbral variation'
    };
    return descriptions[waveform] || 'Oscillator waveform';
  }
}

/**
 * FilterTemplate: Generate filter code
 */
class FilterTemplate extends CodeTemplate {
  constructor() {
    super('filter', 'Generate filter (lowpass, highpass, bandpass, notch)', 'processing');
    this.filterTypes = ['lowpass', 'highpass', 'bandpass', 'notch'];
  }

  validateParams(params) {
    const errors = [];
    if (!params.filterType || !this.filterTypes.includes(params.filterType)) {
      errors.push(`Invalid filterType. Must be one of: ${this.filterTypes.join(', ')}`);
    }
    if (params.order && (params.order < 1 || params.order > 8)) {
      errors.push('Filter order must be between 1 and 8');
    }
    return { valid: errors.length === 0, errors };
  }

  generate(params) {
    const {
      filterType = 'lowpass',
      order = 4,
      freqDefault = 1000,
      freqMin = 20,
      freqMax = 20000,
      qDefault = 1.0,
      name = filterType + '_filter'
    } = params;

    const filterFunction = this.getFilterFunction(filterType, order);
    const description = this.getDescription(filterType);
    const qControl = (filterType === 'bandpass' || filterType === 'notch')
      ? `q = hslider("[1]Resonance (Q)", ${qDefault}, 0.1, 10, 0.1);\n`
      : '';
    const qParam = (filterType === 'bandpass' || filterType === 'notch') ? ', q' : '';

    return `// ═══════════════════════════════════════════════════════════════════════════
// ${filterType.toUpperCase()} FILTER
// ═══════════════════════════════════════════════════════════════════════════
//
// ${description}
// Order: ${order}
//
// Generated by Faust Code Generator
// Timestamp: ${new Date().toISOString()}
//
// ═══════════════════════════════════════════════════════════════════════════

import("stdfaust.lib");

// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

cutoff = hslider("[0]Cutoff (Hz)", ${freqDefault}, ${freqMin}, ${freqMax}, 1);
${qControl}
// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name}(x) = x : ${filterFunction}(${order}, cutoff${qParam});

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};

// ═══════════════════════════════════════════════════════════════════════════
`;
  }

  getFilterFunction(filterType, order) {
    const functions = {
      'lowpass': 'fi.lowpass',
      'highpass': 'fi.highpass',
      'bandpass': 'fi.resonbp',
      'notch': 'fi.notchw'
    };
    return functions[filterType] || 'fi.lowpass';
  }

  getDescription(filterType) {
    const descriptions = {
      'lowpass': 'Low-pass filter - attenuates frequencies above cutoff',
      'highpass': 'High-pass filter - attenuates frequencies below cutoff',
      'bandpass': 'Band-pass filter - passes frequencies around center with Q control',
      'notch': 'Notch filter - rejects frequencies around center with Q control'
    };
    return descriptions[filterType] || 'Audio filter';
  }
}

/**
 * EffectTemplate: Generate audio effect code
 */
class EffectTemplate extends CodeTemplate {
  constructor() {
    super('effect', 'Generate audio effect (delay, reverb, chorus, distortion)', 'effects');
    this.effectTypes = ['delay', 'reverb', 'chorus', 'distortion', 'tremolo', 'flanger'];
  }

  validateParams(params) {
    const errors = [];
    if (!params.effectType || !this.effectTypes.includes(params.effectType)) {
      errors.push(`Invalid effectType. Must be one of: ${this.effectTypes.join(', ')}`);
    }
    return { valid: errors.length === 0, errors };
  }

  generate(params) {
    const {
      effectType = 'delay',
      name = effectType + '_effect'
    } = params;

    const effectCode = this.getEffectCode(effectType, name);
    const description = this.getDescription(effectType);

    return `// ═══════════════════════════════════════════════════════════════════════════
// ${effectType.toUpperCase()} EFFECT
// ═══════════════════════════════════════════════════════════════════════════
//
// ${description}
//
// Generated by Faust Code Generator
// Timestamp: ${new Date().toISOString()}
//
// ═══════════════════════════════════════════════════════════════════════════

import("stdfaust.lib");

${effectCode}

// ═══════════════════════════════════════════════════════════════════════════
`;
  }

  getEffectCode(effectType, name) {
    const effects = {
      'delay': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

delayTime = hslider("[0]Delay Time (ms)", 250, 1, 2000, 1) : *(ma.SR/1000);
feedback = hslider("[1]Feedback", 0.5, 0, 0.95, 0.01);
mix = hslider("[2]Dry/Wet", 0.5, 0, 1, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name}(x) = x * (1 - mix) + delayed * mix
with {
  delayed = (x + delayed' @ delayTime : *(feedback));
};

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};`,

      'reverb': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

roomSize = hslider("[0]Room Size", 0.5, 0, 1, 0.01);
damping = hslider("[1]Damping", 0.5, 0, 1, 0.01);
mix = hslider("[2]Dry/Wet", 0.3, 0, 1, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name} = _ <: *(1 - mix), re.mono_freeverb(roomSize, damping, 0.5) * mix :> _;

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};`,

      'chorus': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

rate = hslider("[0]Rate (Hz)", 1.5, 0.1, 10, 0.1);
depth = hslider("[1]Depth", 0.5, 0, 1, 0.01);
mix = hslider("[2]Dry/Wet", 0.5, 0, 1, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name}(x) = x * (1 - mix) + modulated * mix
with {
  lfo = os.osc(rate) * depth * 0.005 * ma.SR;
  modulated = x @ (lfo + 0.01 * ma.SR);
};

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};`,

      'distortion': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

drive = hslider("[0]Drive", 5, 1, 100, 0.1);
tone = hslider("[1]Tone", 5000, 200, 10000, 10);
level = hslider("[2]Output Level", 0.5, 0, 1, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name}(x) = x * drive : clip : fi.lowpass(3, tone) : *(level)
with {
  clip(s) = max(-1, min(1, s));
};

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};`,

      'tremolo': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

rate = hslider("[0]Rate (Hz)", 5, 0.1, 20, 0.1);
depth = hslider("[1]Depth", 0.5, 0, 1, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name}(x) = x * modulation
with {
  lfo = os.osc(rate) * depth * 0.5 + (1 - depth * 0.5);
  modulation = lfo;
};

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};`,

      'flanger': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

rate = hslider("[0]Rate (Hz)", 0.5, 0.05, 5, 0.01);
depth = hslider("[1]Depth", 0.5, 0, 1, 0.01);
feedback = hslider("[2]Feedback", 0.5, 0, 0.95, 0.01);

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name}(x) = x + flanged
with {
  lfo = os.osc(rate) * depth * 0.002 * ma.SR + 0.003 * ma.SR;
  flanged = (x + flanged' @ lfo : *(feedback));
};

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT
// ───────────────────────────────────────────────────────────────────────────

process = ${name};`
    };

    return effects[effectType] || effects['delay'];
  }

  getDescription(effectType) {
    const descriptions = {
      'delay': 'Simple delay effect with feedback control',
      'reverb': 'Reverb effect using Freeverb algorithm',
      'chorus': 'Chorus effect with modulated delay line',
      'distortion': 'Distortion effect with tone control',
      'tremolo': 'Tremolo effect - amplitude modulation',
      'flanger': 'Flanger effect - short modulated delay with feedback'
    };
    return descriptions[effectType] || 'Audio effect';
  }
}

/**
 * EnvelopeTemplate: Generate envelope code
 */
class EnvelopeTemplate extends CodeTemplate {
  constructor() {
    super('envelope', 'Generate envelope (ADSR, AR, AD)', 'control');
    this.envelopeTypes = ['adsr', 'ar', 'ad'];
  }

  validateParams(params) {
    const errors = [];
    if (!params.envelopeType || !this.envelopeTypes.includes(params.envelopeType)) {
      errors.push(`Invalid envelopeType. Must be one of: ${this.envelopeTypes.join(', ')}`);
    }
    return { valid: errors.length === 0, errors };
  }

  generate(params) {
    const {
      envelopeType = 'adsr',
      name = envelopeType + '_envelope'
    } = params;

    const envelopeCode = this.getEnvelopeCode(envelopeType, name);
    const description = this.getDescription(envelopeType);

    return `// ═══════════════════════════════════════════════════════════════════════════
// ${envelopeType.toUpperCase()} ENVELOPE
// ═══════════════════════════════════════════════════════════════════════════
//
// ${description}
//
// Generated by Faust Code Generator
// Timestamp: ${new Date().toISOString()}
//
// ═══════════════════════════════════════════════════════════════════════════

import("stdfaust.lib");

${envelopeCode}

// ═══════════════════════════════════════════════════════════════════════════
`;
  }

  getEnvelopeCode(envelopeType, name) {
    const envelopes = {
      'adsr': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

attack = hslider("[0]Attack (s)", 0.01, 0.001, 2, 0.001);
decay = hslider("[1]Decay (s)", 0.1, 0.001, 2, 0.001);
sustain = hslider("[2]Sustain", 0.7, 0, 1, 0.01);
release = hslider("[3]Release (s)", 0.5, 0.001, 5, 0.001);
gate = button("[4]Gate");

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name} = en.adsr(attack, decay, sustain, release, gate);

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT (multiply with oscillator/signal)
// ───────────────────────────────────────────────────────────────────────────

// Example usage:
// process = os.osc(440) * ${name};

process = ${name};`,

      'ar': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

attack = hslider("[0]Attack (s)", 0.01, 0.001, 2, 0.001);
release = hslider("[1]Release (s)", 0.5, 0.001, 5, 0.001);
gate = button("[2]Gate");

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name} = en.ar(attack, release, gate);

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT (multiply with oscillator/signal)
// ───────────────────────────────────────────────────────────────────────────

// Example usage:
// process = os.osc(440) * ${name};

process = ${name};`,

      'ad': `// ───────────────────────────────────────────────────────────────────────────
// CONTROLS
// ───────────────────────────────────────────────────────────────────────────

attack = hslider("[0]Attack (s)", 0.01, 0.001, 2, 0.001);
decay = hslider("[1]Decay (s)", 0.5, 0.001, 5, 0.001);
trigger = button("[2]Trigger");

// ───────────────────────────────────────────────────────────────────────────
// SIGNAL PROCESSING
// ───────────────────────────────────────────────────────────────────────────

${name} = en.adsr(attack, decay, 0, 0.001, trigger);

// ───────────────────────────────────────────────────────────────────────────
// OUTPUT (multiply with oscillator/signal)
// ───────────────────────────────────────────────────────────────────────────

// Example usage:
// process = os.osc(440) * ${name};

process = ${name};`
    };

    return envelopes[envelopeType] || envelopes['adsr'];
  }

  getDescription(envelopeType) {
    const descriptions = {
      'adsr': 'Attack-Decay-Sustain-Release envelope for sustained notes',
      'ar': 'Attack-Release envelope for simple envelopes',
      'ad': 'Attack-Decay envelope for percussive sounds'
    };
    return descriptions[envelopeType] || 'Envelope generator';
  }
}

/**
 * CodeGenerator: Main code generator class
 */
class CodeGenerator {
  constructor() {
    this.templates = {
      oscillator: new OscillatorTemplate(),
      filter: new FilterTemplate(),
      effect: new EffectTemplate(),
      envelope: new EnvelopeTemplate()
    };
  }

  /**
   * List available templates
   * @returns {array} Template information
   */
  listTemplates() {
    return Object.entries(this.templates).map(([key, template]) => ({
      name: key,
      description: template.description,
      category: template.category
    }));
  }

  /**
   * Generate code from template
   * @param {string} templateName - Template to use
   * @param {object} params - Template parameters
   * @returns {object} Generation result
   */
  generate(templateName, params = {}) {
    const template = this.templates[templateName];

    if (!template) {
      return {
        success: false,
        error: `Unknown template: ${templateName}. Available: ${Object.keys(this.templates).join(', ')}`
      };
    }

    // Validate parameters
    const validation = template.validateParams(params);
    if (!validation.valid) {
      return {
        success: false,
        error: 'Parameter validation failed',
        errors: validation.errors
      };
    }

    // Generate code
    try {
      const code = template.generate(params);
      return {
        success: true,
        code,
        template: templateName,
        params
      };
    } catch (error) {
      return {
        success: false,
        error: `Code generation failed: ${error.message}`
      };
    }
  }

  /**
   * Generate and save to file
   * @param {string} templateName - Template to use
   * @param {object} params - Template parameters
   * @param {string} outputPath - Output file path
   * @returns {object} Save result
   */
  generateToFile(templateName, params, outputPath) {
    const result = this.generate(templateName, params);

    if (!result.success) {
      return result;
    }

    try {
      fs.writeFileSync(outputPath, result.code, 'utf8');
      return {
        success: true,
        message: `Code generated successfully: ${outputPath}`,
        file: outputPath
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to write file: ${error.message}`
      };
    }
  }
}

// Export for module use
module.exports = {
  CodeGenerator,
  OscillatorTemplate,
  FilterTemplate,
  EffectTemplate,
  EnvelopeTemplate
};

// CLI support
if (require.main === module) {
  const args = process.argv.slice(2);

  const generator = new CodeGenerator();

  if (args.length === 0 || args.includes('--help')) {
    console.log('Faust Code Generator');
    console.log('');
    console.log('Usage:');
    console.log('  node code-generator.js list                          # List available templates');
    console.log('  node code-generator.js <template> [options]          # Generate code');
    console.log('');
    console.log('Available Templates:');
    generator.listTemplates().forEach(t => {
      console.log(`  ${t.name.padEnd(15)} - ${t.description}`);
    });
    console.log('');
    console.log('Examples:');
    console.log('  # Generate sine oscillator');
    console.log('  node code-generator.js oscillator --waveform=sine --output=my-sine.dsp');
    console.log('');
    console.log('  # Generate lowpass filter');
    console.log('  node code-generator.js filter --filterType=lowpass --order=4 --output=my-filter.dsp');
    console.log('');
    console.log('  # Generate delay effect');
    console.log('  node code-generator.js effect --effectType=delay --output=my-delay.dsp');
    console.log('');
    console.log('  # Generate ADSR envelope');
    console.log('  node code-generator.js envelope --envelopeType=adsr --output=my-envelope.dsp');
    process.exit(0);
  }

  if (args[0] === 'list') {
    console.log('Available Templates:\n');
    generator.listTemplates().forEach(t => {
      console.log(`${t.name}`);
      console.log(`  Category: ${t.category}`);
      console.log(`  Description: ${t.description}`);
      console.log('');
    });
    process.exit(0);
  }

  const templateName = args[0];
  const params = {};
  let outputPath = null;

  // Parse arguments
  for (let i = 1; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const [key, value] = arg.substring(2).split('=');
      if (key === 'output') {
        outputPath = value;
      } else {
        // Try to parse as number
        const numValue = parseFloat(value);
        params[key] = isNaN(numValue) ? value : numValue;
      }
    }
  }

  if (outputPath) {
    const result = generator.generateToFile(templateName, params, outputPath);
    if (result.success) {
      console.log(`✓ ${result.message}`);
      process.exit(0);
    } else {
      console.error(`✗ ${result.error}`);
      if (result.errors) {
        result.errors.forEach(err => console.error(`  - ${err}`));
      }
      process.exit(1);
    }
  } else {
    const result = generator.generate(templateName, params);
    if (result.success) {
      console.log(result.code);
      process.exit(0);
    } else {
      console.error(`✗ ${result.error}`);
      if (result.errors) {
        result.errors.forEach(err => console.error(`  - ${err}`));
      }
      process.exit(1);
    }
  }
}
